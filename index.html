<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-y: hidden;
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            overflow-y: hidden;
            overflow-x: hidden;
            border: 1px black solid;
        }
        main {
            padding: 20px;
            border: 1px black solid;
        }
        section {
            width: auto;
            height: auto;
            border: 1px black dashed;
            text-indent: 20px;
            padding: 10px;
            margin: 10px;
            margin-top: 0px;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <canvas onmousemove="getMousePos(event, canvas)" id="Window">This element is unsupported.</canvas>
        <section>
            <b id="name"></b>
            <span id="output"></span>
        </section>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        game_state = 0;

        MapX = 100;
        MapY = 50;
        size_X = 3;
        size_Y = 3;

        mouse_x = 0;
        mouse_y = 0;

        t = 0;
        night = false;

        scan = false;
        c = 1;

        geode = []; // 2 values X, Y
        entity = []; // 3 Values ID, X, Y
        dig_attempt = []; // previous dig locations

        function innit(e) {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            canvas.addEventListener("keydown", keyDown);
            canvas.addEventListener("keyup", keyUp);
            canvas.addEventListener("keypress", keyPress);
            canvas.addEventListener("click", Click);

            map = new map_Gen(2, 50, 25, MapX, MapY);
            geode_Gen();

            setInterval(main, 20);
            setInterval(draw, 20);
        }

        function main() {
            clear();

            document.getElementById("output").innerHTML = String(mouse_x+" "+mouse_y)

            if (night == true) {
                t -= 2;
            } else {
                t += 2;
            }

            if (t == 1200) {
                night = true;
            } else if (t == 0) {
                night = false
            }
            
            if (game_state == 0) {
                map_Render(0, (MapX), (MapY), 0, 0, size_X, size_Y, scan);
                geode_Gen();
            }
        }

        function geode_Gen() {
            if (geode.length < c) {
                for (i = geode.length; i < c; i ++) {
                    temp_pos = [Math.round(range(Math.random()*MapX), 0, 1000), Math.round(range(Math.random()*1000), 120, 1000)];
                    geode.push(temp_pos);
                }
            }
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        function map_Render(biome, maxX, maxY, cx, cz, size_x, size_z, scan) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (y = cz; y < maxY; y++) {
                    // color = "hsl(210, 100%, "+map[x][y]+"%)";
                    if (biome == 0) {
                        temp_val = map[x][y]-t/100;
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    }
                    if (biome == 1) {
                        if (map[x][y] >= 10) {
                            temp_val = range(map[x][y], 10, 20)
                            color = "hsl(100, 93%, "+temp_val+"%)";
                        } else {
                            temp_val = range(map[x][y], 21, 36)
                            color = "hsl(221, 55%, "+temp_val+"%)";
                        }
                    }

                    // if (map[temp_x][temp_z] < 5) {
                        
                    // }
                    draw(1, true, color, x*size_x, y*size_z, size_x, size_z);
                    temp_z += 1
                }
                temp_x += 1
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxY) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][y]+diff < MaxV && gen[x][y]+diff > MinV) {
                        gen[x][y] += diff;
                    }

                    for (t = 0; t < 4; t ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (t == 0 && gen[x-1][y]+diff < MaxV && gen[x-1][y]+diff > MinV) {
                                gen[x-1][y] = Math.round((gen[x][y]+gen[x-1][y])/2);
                                gen[x-1][y] +=diff;
                            }
                            if (t == 1 && gen[x+1][y]+diff < MaxV && gen[x+1][y]+diff > MinV) {
                                gen[x+1][y] = Math.round((gen[x][y]+gen[x+1][y])/2);
                                gen[x+1][y] += diff;
                            }
                        }

                        if (y-1 > 0 && y+1  < MaxY) {
                            if (t == 2 && gen[x][y-1]+diff < MaxV && gen[x][y-1]+diff > MinV) {
                                gen[x][y-1] = Math.round((gen[x][y]+gen[x][y-1])/2);
                                gen[x][y-1] += diff;
                            }
                            if (t == 3 && gen[x][y+1]+diff < MaxV && gen[x][y+1]+diff > MinV) {
                                gen[x][y+1] = Math.round((gen[x][y]+gen[x][y+1])/2);
                                gen[x][y+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;
        }

        function keyUp() {
            var keyCode = event.keyCode;
        }

        function keyPress() {
            var keyCode = event.keyCode;

            if (keyCode == 32) {
                scan = true;
            }
        }

        function getMousePos(e, canvas) {
            var rect = canvas.getBoundingClientRect();
            scaleX = canvas.width / rect.width;
            scaleY = canvas.height / rect.height;

            mouse_x = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width));
            mouse_y = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height));
        }

        function Click() {
            temp_pos = [mouse_x-30, mouse_y-120];
            dig_attempt.push(temp_pos);
            for (x = 0; x < geode.length/2; x++) {
                for (y = 0; y < geode.length/2+1; y++) {
                    if (temp_pos[0] > geode[x]-size_X/2 && temp_pos[0] < geode[x]-size_X/2) {
                        if (temp_pos[1] > geode[y]-size_Y/2 && temp_pos[1] < geode[y]-size_Y/2) {
                            document.getElementById("output").innerHTML = "True";
                        }
                    }
                }
            }
        }

        function draw(type, fill, color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }
            if (type == 2 && fill == false) {
                ctx.arc(x, y, size_x+size_y/2, Math.pi, Math.pi, false);
            }

            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke()
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>