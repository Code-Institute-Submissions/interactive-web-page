<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            overflow-y: hidden;
            overflow-x: hidden;
            border: 1px black solid;
        }
        main {
            padding: 20px;
            border: 1px black solid;
        }
        section {
            width: auto;
            height: auto;
            border: 1px black dashed;
            text-indent: 20px;
            padding: 10px;
            margin: 10px;
            margin-top: 0px;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <canvas onmousemove="getMousePos(event, canvas)" id="Window">This element is unsupported.</canvas>
        <section>
            <b id="name"></b>
            <span id="output"></span>
        </section>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        game_state = 1;

        MapX = 15;
        MapY = 8;
        size_X = 20;
        size_Y = 20;
        origin = 5;

        mouse_x = 0;
        mouse_y = 0;

        t = 0;
        night = false;
        scanned = false;

        c = 1;
        active = 0;

        inventory = [];

        biome = 0;

        geode = [];
        entity = []; // 3 Values ID, X, Y
        dig_attempt = []; // previous dig locations

        function innit() {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            document.addEventListener("keydown", keyDown);
            document.addEventListener("click", Click);

            map = new map_Gen(2, 50, 25, MapX, MapY);

            setInterval(main, 20);
            setInterval(draw, 20);
        }

        function main() {
            document.getElementById("output").innerHTML = String(inventory);

            if (active > 0) {
                active --;
            }

            if (night == true) {
                t -= 1;
            } else {
                t += 1;
            }

            if (t == 1200) {
                night = true;
            } else if (t == 0) {
                night = false
            }

            if (game_state == 3) {
                clear();
                map_Render(biome, (MapX), (MapY), origin, origin, size_X, size_Y);
                entity_Render();
                geode_Gen();
                game_state = 4;
            }

            if (geode.length != 0) {
                if (t % 100 == 0) {
                    clear();
                    map_Render(biome, (MapX), (MapY), origin, origin, size_X, size_Y);
                    entity_Render();
                }
            }
        }

        function entity_Render() {
            temp_val = 30-t/100;

            color = "hsl(19, 29%,"+temp_val+"%)";
            s_color = "hsl(144, 47%,"+temp_val+"%)";

            draw(12, true, color, s_color, 100, 100, size_X, size_Y);
        }

        function geode_Render() {
            for (i = 0; i < geode.length/2; i++) {
                temp_val = 20-t/100;

                if (biome == 0) {
                    color = "hsl(122, 54%, "+temp_val+"%)";
                }

                draw(1, true, color, "", geode[i*2]-size_X, geode[i*2+1]-size_Y, size_X*2, size_Y*2);
            }
        }

        function geode_Gen() {
            if (geode.length < c) {
                for (i = geode.length; i < c; i ++) {
                    temp_pos = [Math.floor(range((Math.random()*zone[0]), size_X*2, zone[0]-size_X*2)), Math.floor(range((Math.random()*zone[1]), size_Y*2, zone[1]-size_Y*2))];
                    geode[geode.length] = parseInt(temp_pos[0]);
                    geode[geode.length] = parseInt(temp_pos[1]);
                }
            }
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        function map_Render(biome, maxX, maxY, cx, cz, size_x, size_z) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (y = cz; y < maxY; y++) {
                    temp_val = map[x][y]-t/100;

                    if (biome == 0) {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    }

                    draw(1, true, color, "", x*size_x, y*size_z, size_x, size_z);
                    temp_z += 1;
                }
                temp_x += 1;
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxY) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][y]+diff < MaxV && gen[x][y]+diff > MinV) {
                        gen[x][y] += diff;
                    }

                    for (t = 0; t < 4; t ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (t == 0 && gen[x-1][y]+diff < MaxV && gen[x-1][y]+diff > MinV) {
                                gen[x-1][y] = Math.round((gen[x][y]+gen[x-1][y])/2);
                                gen[x-1][y] +=diff;
                            }
                            if (t == 1 && gen[x+1][y]+diff < MaxV && gen[x+1][y]+diff > MinV) {
                                gen[x+1][y] = Math.round((gen[x][y]+gen[x+1][y])/2);
                                gen[x+1][y] += diff;
                            }
                        }

                        if (y-1 > 0 && y+1  < MaxY) {
                            if (t == 2 && gen[x][y-1]+diff < MaxV && gen[x][y-1]+diff > MinV) {
                                gen[x][y-1] = Math.round((gen[x][y]+gen[x][y-1])/2);
                                gen[x][y-1] += diff;
                            }
                            if (t == 3 && gen[x][y+1]+diff < MaxV && gen[x][y+1]+diff > MinV) {
                                gen[x][y+1] = Math.round((gen[x][y]+gen[x][y+1])/2);
                                gen[x][y+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;

            if (keyCode == 32 && scanned == false) {
                geode_Render();
                active = 100;
                scanned = true;
            }
        }

        function keyPress() {
            var keyCode = event.keyCode;
        }

        function getMousePos(e, canvas) {
            var rect = canvas.getBoundingClientRect();

            scaleX = canvas.width / rect.width;
            scaleY = canvas.height / rect.height;
            zone = [Math.round(rect.width * scaleX), Math.round(rect.height * scaleY)]

            mouse_x = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
            mouse_y = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
        }

        function addItem(item, quantity) {
            if (inventory.includes(item)) {
                for (i = 0; i < inventory.length/2; i++) {
                    if (inventory[i*2] == item) {
                        inventory[i*2+1] += 1;
                    }
                }
            } else {
                inventory.push(item);
                inventory.push(quantity);
            }
        }

        function randomItem(itemC) {
            if (itemC == 0) {
                addItem("Geode", 1);
            }
            if (itemC == 1) {
                r = Math.random()
                if (r > 0.5) {
                    addItem("Geode", 1);
                } else if (r > 0.4) {
                    addItem("Copper ore", 1);
                } else if (r > 0.3) {
                    addItem("Tin", 1);
                } else if (r > 0.2) {
                    addItem("Fossil", 1);
                } else if (r > 0.19) {
                    addItem("Iron ore", 1);
                } else if (r > 0.18) {
                    addItem("Gold ore", 1);
                } else if (r > 0.16) {
                    addItem("Diamond", 1);
                }  else if (r > 0.15) {
                    addItem("Ruby", 1);
                }  else if (r > 0) {
                    addItem("Geode", 1);
                }
            }
        }

        function displayInv() {
            text = ""
            for (i = 0; i < inventory.length/2; i ++) {
                if (inventory[i*2+1] == 1) {
                    text = String(text+", "+inventory[i*2])
                } else {
                    text = String(text+", "+inventory[i*2+1]+" "+inventory[i*2])
                }
            }
        }

        function Click() {
            if (scanned == true) {
                dig_attempt[dig_attempt.length] = parseInt(mouse_x);
                dig_attempt[dig_attempt.length] = parseInt(mouse_y);
                
                for (i = 0; i < geode.length/2; i++) {
                    if (mouse_x >= geode[i*2]-size_X && mouse_x <= geode[i*2]+size_X && mouse_y >= geode[i*2+1]-size_X && mouse_y <= geode[i*2+1]+size_Y) {
                        delete geode[i*2+1];
                        delete geode[i*2];
                        randomItem(1);
                    }
                }
            }
        }

        function draw(type, fill, color, s_color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }

            if (type == 11) {
                ctx.fillStyle = "hsl(0, 0%, 20%)";
                ctx.fillRect(x, y, size_x, size_y/2);
                ctx.fillRect(x+size_x, y+size_y/4, size_x/4, size_y/4);
            }
            if (type == 12) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, size_x/2, size_y/2);
                ctx.fillStyle = s_color;
                ctx.strokeStyle = s_color;
                ctx.moveTo(x-size_x/2, y);
                ctx.lineTo(x+size_x/4, y-size_y*2);
                ctx.lineTo(x+size_x+size_x/32, y);
                ctx.lineTo(x-size_x/2, y);
                ctx.fill();
            }

            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke()
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>