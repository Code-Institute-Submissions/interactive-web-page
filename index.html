<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            overflow-y: hidden;
            overflow-x: hidden;
            border: 1px black solid;
            position: absolute;
            visibility: collapse;
        }
        main {
            padding: 20px;
            border: 1px black solid;
        }
        section {
            width: auto;
            height: auto;
            border: 1px black dashed;
            text-indent: 20px;
            padding: 10px;
            margin-bottom: 10px;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <section>
            <b id="name"></b>
            <span id="output"></span>
        </section>
        <canvas onmousemove="getMousePos(event, canvas)" id="Window">This element is unsupported.</canvas>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        game_state = 0;

        MapX = 50;
        MapY = 30;
        size_X = 6;
        size_Y = 6;
        origin = 1;

        mouse_x = 0;
        mouse_y = 0;

        t = 0;
        night = false;
        scanned = false;

        c = 1;
        active = 0;

        inventory = [];

        biome = 0;

        user = false;
        bool = false;
        select = 1;

        geode = [];
        entity = []; // 3 Values ID, X, Y
        dig_attempt = []; // previous dig locations

        response = ["Welcome to DIG UP! This is a game developed by me just to be presented for my course. The game is only going to have some simple little mini-games and will be just a little bit of fun.", "Hello. I am your assistant, just call me Alph. I will tell you about the game and how to play.", "W and S allow for navigation in menu screens and other text related displays.", "Spacebar and Enter will be the confirm button. But whilst in game will allow the user to visually display the locations of items in the ground.", "Q and E will act as a quick time event where the user will be made to respond within a certain amount of time.", "A, S and D will also act as a quick time response event within salvaging and recovering geodes and other items.", "Within this part of the screen this will allow for menu select and from here you can chose to see your inventory, also go and find resources and also salvage or obtained items.","What would you like to do?", "", "", "What biome would you like to explore?", "Now you can use the Spacebar to scan for any irregular parts of terrain.", ""];

        function innit() {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            document.addEventListener("keydown", keyDown);
            document.addEventListener("click", Click);

            document.getElementById("name").innerHTML = "???:"
            document.getElementById("output").innerHTML = response[game_state*10]+"<br><br> Press any button to continue.";
            setInterval(alph, 20);
        }

        function alph() {
            if (user == true && game_state < 0.7) {
                if (game_state == 0.1) {
                    document.getElementById("name").innerHTML = "Alph:"
                }
                game_state += 0.1;
                user = false;
            }

            if (game_state < 0.7) {
                document.getElementById("output").innerHTML = response[game_state*10]+"<br><br> Press any button to continue.";
            }
            if (game_state == 0.7) {
                if (select == 1) {
                    temp = String("</br><b> World Map</b></br>Museum</br> Inventory")
                } else if (select == 2) {
                    temp = String("</br>World Map</br><b>Museum</b></br> Inventory")
                } else if (select == 3) {
                    temp = String("</br>World Map</br>Museum</br><b>Inventory</b>")
                }
                if (user == true) {
                    user = false;
                    game_state = select;
                    select = 1;
                }
                document.getElementById("output").innerHTML = response[game_state*10]+temp;
            }
            if (game_state == 1) {
                if (select == 0) {
                    game_state == 0.7;
                }
                if (select == 1) {
                    temp = String("</br><b>Plains</b></br>Swamp</br> Mountain");
                } else if (select == 2) {
                    temp = String("</br>Resume</br><b>Plains</b></br>Swamp</br>Mountain");
                } else if (select == 3) {
                    temp = String("</br>Resume</br>Plains</br><b>Swamp</b></br>Mountain");
                } 
                if (user == true) {
                    user = false;
                    game_state = 1.1;
                    toggle(true);
                    biome(select);
                }
                document.getElementById("output").innerHTML = response[game_state*10]+temp;
            }
            if (game_state == 1.1) {
                document.getElementById("output").innerHTML = String(map);
            }
        }
        
        function toggle(bool) {
            if (bool == true) {
                document.getElementById("Window").style.visibility = "visible";
                document.getElementById("Window").style.position = "static";
            } else if (bool == false) {
                document.getElementById("Window").style.visibility = "hidden";
                document.getElementById("Window").style.position = "absoulte";
            }
        }

        function biome(value) {
            map = new map_Gen(2, 50, 25, MapX, MapY);
            map_Render(value, (MapX), (MapY), 0, 0, size_X, size_Y);
            geode_Gen();
        }

        function main() {
            if (scanned == true) {
                active --;
            } else if (active < 200){
                active++;
            }

            if (night == true) {
                t -= 1;
            } else {
                t += 1;
            }

            if (t == 1200) {
                night = true;
            } else if (t == 0) {
                night = false;
            }

            if (geode.length != 0) {
                if (t % 100 == 0) {
                    clear();
                    map_Render(biome, (MapX), (MapY), 0, origin, size_X, size_Y);
                    gui_Render();
                }
            }
        }

        function entity_Render() {
            temp_val = 30-t/100;

            color = "hsl(19, 29%,"+temp_val+"%)";
            s_color = "hsl(144, 47%,"+temp_val+"%)";

            draw(12, true, color, s_color, 100, 100, size_X, size_Y);
        }

        function geode_Render() {
            for (i = 0; i < geode.length/2; i++) {
                temp_val = 20-t/100;

                if (biome == 0) {
                    color = "hsl(122, 54%, "+temp_val+"%)";
                }

                draw(1, true, color, "", geode[i*2]-size_X, geode[i*2+1]-size_Y, size_X*2, size_Y*2);
            }
        }

        function geode_Gen() {
            if (geode.length < c) {
                for (i = geode.length; i < c; i ++) {
                    temp_pos = [Math.floor(range((Math.random()*zone[0]), size_X*2, zone[0]-size_X*2)), Math.floor(range((Math.random()*zone[1]), size_Y*2, zone[1]-size_Y*2))];
                    geode[geode.length] = parseInt(temp_pos[0]);
                    geode[geode.length] = parseInt(temp_pos[1]);
                }
            }
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        function map_Render(biome, maxX, maxY, cx, cz, size_x, size_z) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (y = cz; y < maxY; y++) {
                    temp_val = map[x][y]-t/100;

                    if (biome == 1) {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    }

                    draw(1, true, color, "", x*size_x, y*size_z, size_x, size_z);
                    temp_z += 1;
                }
                temp_x += 1;
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxY) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][y]+diff < MaxV && gen[x][y]+diff > MinV) {
                        gen[x][y] += diff;
                    }

                    for (t = 0; t < 4; t ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (t == 0 && gen[x-1][y]+diff < MaxV && gen[x-1][y]+diff > MinV) {
                                gen[x-1][y] = Math.round((gen[x][y]+gen[x-1][y])/2);
                                gen[x-1][y] +=diff;
                            }
                            if (t == 1 && gen[x+1][y]+diff < MaxV && gen[x+1][y]+diff > MinV) {
                                gen[x+1][y] = Math.round((gen[x][y]+gen[x+1][y])/2);
                                gen[x+1][y] += diff;
                            }
                        }

                        if (y-1 > 0 && y+1  < MaxY) {
                            if (t == 2 && gen[x][y-1]+diff < MaxV && gen[x][y-1]+diff > MinV) {
                                gen[x][y-1] = Math.round((gen[x][y]+gen[x][y-1])/2);
                                gen[x][y-1] += diff;
                            }
                            if (t == 3 && gen[x][y+1]+diff < MaxV && gen[x][y+1]+diff > MinV) {
                                gen[x][y+1] = Math.round((gen[x][y]+gen[x][y+1])/2);
                                gen[x][y+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;

            if (game_state < 0.7) {
                user = true;
            }

            if (game_state == 0.7) {
                if (keyCode == 87 && select > 1) {
                    select -= 1
                } else if (keyCode == 83 && select < 3) {
                    select += 1
                } else if (keyCode == 13 || keyCode == 32) {
                    user = true;
                }
            }

            if (game_state == 1) {
                if (keyCode == 87 && select > 1) {
                    select -= 1
                } else if (keyCode == 83 && select < 8) {
                    select += 1
                } else if (keyCode == 27 || keyCode == 8) {
                    select = 0
                } else if (keyCode == 13 || keyCode == 32) {
                    user = true;
                }
            }

            if (keyCode == 32 && game_state > 1) {
                geode_Render();
                if (scanned == false && active > 0) {
                    scanned = true;
                } else {
                    scanned = false;
                }
            }
        }

        function keyPress() {
            var keyCode = event.keyCode;
        }

        function getMousePos(e, canvas) {
            var rect = canvas.getBoundingClientRect();

            scaleX = canvas.width / rect.width;
            scaleY = canvas.height / rect.height;
            zone = [Math.round(rect.width * scaleX), Math.round(rect.height * scaleY)];

            mouse_x = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
            mouse_y = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
        }

        function addItem(item, quantity) {
            if (inventory.includes(item)) {
                for (i = 0; i < inventory.length/2; i++) {
                    if (inventory[i*2] == item) {
                        inventory[i*2+1] += 1;
                    }
                }
            } else {
                inventory.push(item);
                inventory.push(quantity);
            }
        }

        function randomItem(itemC) {
            if (itemC == 0) {
                addItem("Geode", 1);
            }
            if (itemC == 1) {
                r = Math.random();
                if (r > 0.5) {
                    addItem("Geode", 1);
                } else if (r > 0.4) {
                    addItem("Copper ore", 1);
                } else if (r > 0.3) {
                    addItem("Tin", 1);
                } else if (r > 0.2) {
                    addItem("Fossil", 1);
                } else if (r > 0.19) {
                    addItem("Iron ore", 1);
                } else if (r > 0.18) {
                    addItem("Gold ore", 1);
                } else if (r > 0.16) {
                    addItem("Diamond", 1);
                }  else if (r > 0.15) {
                    addItem("Ruby", 1);
                }  else if (r > 0) {
                    addItem("Geode", 1);
                }
            }
        }

        function displayInv() {
            text = "";
            for (i = 0; i < inventory.length/2; i ++) {
                if (inventory[i*2+1] == 1) {
                    text = String(text+", "+inventory[i*2]);
                } else {
                    text = String(text+", "+inventory[i*2+1]+" "+inventory[i*2]);
                }
            }
            return text;
        }

        function Click() {
            if (scanned == true) {
                dig_attempt[dig_attempt.length] = parseInt(mouse_x);
                dig_attempt[dig_attempt.length] = parseInt(mouse_y);
                
                for (i = 0; i < geode.length/2; i++) {
                    if (mouse_x >= geode[i*2]-size_X && mouse_x <= geode[i*2]+size_X && mouse_y >= geode[i*2+1]-size_X && mouse_y <= geode[i*2+1]+size_Y) {
                        delete geode[i*2+1];
                        delete geode[i*2];
                        randomItem(1);
                    }
                }
            }
        }

        function draw(type, fill, color, s_color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }

            if (type == 11) {
                ctx.fillStyle = "hsl(0, 0%, 20%)";
                ctx.fillRect(x, y, size_x, size_y/2);
                ctx.fillRect(x+size_x, y+size_y/4, size_x/4, size_y/4);
            }
            if (type == 12) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, size_x/2, size_y/2);
                ctx.fillStyle = s_color;
                ctx.strokeStyle = s_color;
                ctx.moveTo(x-size_x/2, y);
                ctx.lineTo(x+size_x/4, y-size_y*2);
                ctx.lineTo(x+size_x+size_x/32, y);
                ctx.lineTo(x-size_x/2, y);
                ctx.fill();
            }

            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke();
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>