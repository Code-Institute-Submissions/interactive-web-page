<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            overflow-y: hidden;
            overflow-x: hidden;
            border: 1px black solid;
        }
        main {
            padding: 20px;
            border: 1px black solid;
        }
        section {
            width: auto;
            height: auto;
            border: 1px black dashed;
            text-indent: 20px;
            padding: 10px;
            margin-bottom: 10px;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <section>
            <b id="name"></b>
            <span id="output"></span>
        </section>
        <canvas onmousemove="getMousePos(event, canvas)" id="Window">This element is unsupported.</canvas>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        let game_state = 0;

        const MapX = 50;
        const MapY = 30;
        const size_X = 6;
        const size_Y = 6;

        let mouse_x = 0;
        let mouse_y = 0;

        let time = 0;
        let night = false;
        let scanned = false;

        let count = 5;
        let active = 0;
        let cooldown = 0;
        let diggable = false;

        let inventory = []; // Inventory array to hold the items the user obtains from the terrain.

        let biome_v = ""; // String for the biome_value of the terrain.

        let user = false; // check for user responses
        let bool = false; // bool cast, helpful to have an empty castable bool
        let select = 1; // Used within the menu to check what the user is currently selected.

        let geode = []; // Array for the XY of each geode location
        let entity = []; // 3 Values ID, X, Y
        let dig_attempt = []; // previous dig locations
        let attempts = 3;
        let sequence = [];
        let SEQUENCE_COMPLETE = false;
        let sequence_len = 0;
        let response_sequence = [];

        let item_select = 0;

        const AFTER_TUTORIAL = 0.7;
        const START_GAME = 1;
        const DURING_GAME = 1.1;
        const SECOND_GAME = 1.2;
        const SEQUENCE_RESPONSE = 1.3;
        const INVENTORY = 3;

        const OUTPUT_ITEMS = [["World Map", "Museum", "Inventory"],["Plains", "Desert", "Forest", "Swamp", "Mountain", "Taiga", "Jungle", "Red Desert", "Savannah", "Marsh"]]
        const OUTPUT = ["Welcome to DIG UP! This is a game developed by me just to be presented for my course. The game is only going to have some simple little mini-games and will be just a little bit of fun.", "Hello. I am your assistant, just call me Alph. I will tell you about the game and how to play.", "W and S allow for navigation in menu screens and other text related displays.", "Spacebar and Enter will be the confirm button. But whilst in game will allow the user to visually display the locations of items in the ground.", "Q and E will be part of a digging mini-game, once you have placed down all of your dig locations, I will tell you the way on which you must dig the terrain to prevent items from being damaged.", "A, S and D will also act as a quick time response event within salvaging and recovering geodes and other items.", "Within this part of the screen this will allow for menu select and from here you can chose to see your inventory, also go and find resources and also salvage or obtained items.","What would you like to do?", "", "", "What biome would you like to explore?", "Now you will have a series of attempts to find the items within the terrian, using spacebar you can see the locations of the items.", "Now you will be given a sequence of characters which will have to be repeated back to be able to dig up the locations you have chosen.", "Now can you repeat the sequence that was just produced.", ""];

        function innit() {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            document.addEventListener("keypress", keyPress);
            document.addEventListener("keydown", keyDown);
            document.addEventListener("click", Click);

            document.getElementById("name").innerHTML = "???:"
            document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"<br><br> Press any button to continue.";
            setInterval(alph, 20);
        }

        function alph() {
            if (user && game_state < AFTER_TUTORIAL) {
                if (game_state == 0.1) {
                    document.getElementById("name").innerHTML = "Alph:"
                }
                game_state += 0.1;
                user = false;
            }

            if (game_state < AFTER_TUTORIAL) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"<br><br> Press any button to continue.";
            } else if (game_state == AFTER_TUTORIAL) {
                item_select = 0;
                temp = OUTPUT_PRINTOUT(OUTPUT_ITEMS[item_select], select);
                if (user) {
                    user = false;
                    game_state = select;
                    select = 1;
                }
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+temp;
            } else if (game_state == START_GAME) {
                item_select = 1;
                temp = OUTPUT_PRINTOUT(OUTPUT_ITEMS[item_select], select);
                if (user) {
                    user = false;
                    game_state = 1.1;
                    biome_v = OUTPUT_ITEMS[1][select-1];
                    biome(biome_v);
                }
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+temp;
            } else if (game_state == DURING_GAME) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"</br></br>Attempts: "+(attempts-(Math.floor(dig_attempt.length/2)));
            } else if (game_state == SECOND_GAME) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"</br></br>Sequence: "+sequence;
            } else if (game_state == SEQUENCE_RESPONSE) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+" You have manageed to find "+inventory[inventory.length-2]+"</br></br>Users Response: "+response_sequence;
            } else if (game_state == INVENTORY) {
                document.getElementById("output").innerHTML = "These are the items that are in your inventory.</br></br>"+displayInv();
                if (user) {
                    game_state = AFTER_TUTORIAL;
                    user = false;
                }
            }
        }

        function OUTPUT_PRINTOUT (items, selected) {
            let temp = "";
            for (x = 0; x < items.length; x++) {
                if (selected-1 == x) {
                    temp = String(temp+"</br><b>"+items[x]+"</b>")
                } else {
                    temp = String(temp+"</br>"+items[x])
                }
            }
            return temp;
        }

        function biome(value) {
            if ("Plains") {
                map = new map_Gen(2, 50, 25, MapX, MapY);
            } else if ("Desert") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Forest") {
                map = new map_Gen(5, 50, 25, MapX, MapY);
            } else if ("Swamp") {
                map = new map_Gen(2, 25, 15, MapX, MapY);
            } else if ("Mountain") {
                map = new map_Gen(2, 85, 60, MapX, MapY);
            } else if ("Jungle") {
                map = new map_Gen(2, 30, 20, MapX, MapY);
            } else if ("Taiga") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Red Desert") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Savannah") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Marsh") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            }
            geode_Gen();
            setInterval(main, 20);
            setInterval(draw, 20);
        }

        function main() {
            if ((time % 100 == 0 || time == 10 || scanned == false) &&  game_state == DURING_GAME) {
                map_Render(biome_v, MapX, MapY, 0, 0, size_X, size_Y);
                dig_Render();
            }

            if (game_state == DURING_GAME) {
                if (scanned == true) {
                    geode_Render();
                }

                if (cooldown > 0) {
                    cooldown --;
                }

                if (scanned == true && active > 0) {
                    active --;
                } else if (active < 100){
                    scanned = false;
                    active++;
                }

                if (night == true) {
                    time -= 1;
                } else {
                    time += 1;
                }

                if (time == 1200) {
                    night = true;
                } else if (time == 0) {
                    night = false;
                }
            }

            if (time % 20 == 0 && game_state == DURING_GAME) {
                if (dig_attempt.length >= attempts*2) {
                    game_state = SECOND_GAME;
                }
            }

            if ((game_state == SECOND_GAME || game_state == SEQUENCE_RESPONSE) && time % 25 == 0 ) {
                clear();
                let CALC_X = Math.round(dig_attempt[0]/size_X)
                let CALC_Y = Math.round(dig_attempt[1]/size_Y)
                map_Render(biome_v, CALC_X+size_X,  CALC_Y+size_Y,  CALC_X-size_X, CALC_Y-size_Y, size_X, size_Y);
                draw(1, true, "hsl(0, 0%, 0%)", "", dig_attempt[0]-size_X, dig_attempt[1]-size_Y, size_X*2, size_Y*2)
                
                if (sequence_len == 0) {
                    sequence_len = (4+(Math.floor(Math.random()*count)));
                    SEQUENCE_COMPLETE = false;
                }
                
                if (sequence.length != sequence_len) {
                    let r = Math.random();
                    if (r > 0.5) {
                        sequence.push("Q");
                    } else {
                        sequence.push("E");
                    }
                }

                if (sequence.length == sequence_len && game_state == SECOND_GAME && SEQUENCE_COMPLETE == false) {
                    SEQUENCE_COMPLETE = true;
                } else if (SEQUENCE_COMPLETE == true) {
                    game_state = SEQUENCE_RESPONSE;
                    SEQUENCE_COMPLETE = false;
                }
                
                if (response_sequence.length == sequence.length) {
                    let item_quality = 100;
                    for (i = 0; i < response_sequence.length; i++) {
                        if (sequence[i] != response_sequence[i]) {
                            item_quality = Math.round(item_quality-(50/sequence_len));
                        }
                    }
                    bool = false;
                    for (i = 0; i < geode.length/2; i++) {
                        if (dig_attempt[0] >= geode[i*2]-size_X && dig_attempt[0] <= geode[i*2]+size_X && dig_attempt[1] >= geode[i*2+1]-size_Y && dig_attempt[1] <= geode[i*2+1]+size_Y) {
                            bool = true;
                        }
                    }
                    if (bool) {
                        randomItem(biome_v, item_quality);
                    } else {
                        randomItem(0, item_quality);
                    }
                    dig_attempt.shift();
                    dig_attempt.shift();
                    sequence = [];
                    response_sequence = [];
                    game_state = SECOND_GAME;
                }

                if (dig_attempt.length == 0) {
                    game_state = AFTER_TUTORIAL;
                    clear();
                }
            }
        }

        function geode_Render() {
            for (i = 0; i < geode.length/2; i++) {
                draw(1, true, "hsl(0, 0%, 0%)", "", geode[i*2]-size_X, geode[i*2+1]-size_Y, size_X*2, size_Y*2);
            }
        }

        function dig_Render() {
            for (i = 0; i < dig_attempt.length/2; i++) {
                draw(1, true, "hsl(0, 0%, 0%)", "", dig_attempt[i*2]-size_X, dig_attempt[i*2+1]-size_Y, size_X*2, size_Y*2);
            }
        }

        function geode_Gen() {
            if (geode.length < count) {
                for (i = geode.length; i < count; i ++) {
                    temp_pos = [Math.floor(range((Math.random()*zone[0]), size_X*2, zone[0]-size_X*2)), Math.floor(range((Math.random()*zone[1]), size_Y*2, zone[1]-size_Y*2))];
                    geode[geode.length] = parseInt(temp_pos[0]);
                    geode[geode.length] = parseInt(temp_pos[1]);
                }
            }
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        function map_Render(biome, maxX, maxY, cx, cz, size_x, size_z) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (y = cz; y < maxY; y++) {
                    temp_val = map[x][y]-time/100;

                    if (biome == "Plains") {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    } else if (biome == "Desert") {
                        color = "hsl(64, 85%, "+temp_val+"%)";
                    } else if (biome == "Forest") {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    } else if (biome == "Swamp") {
                        color = "hsl(145, 88%, "+temp_val+"%)";
                    } 

                    draw(1, true, color, "", x*size_x, y*size_z, size_x, size_z);
                    temp_z += 1;
                }
                temp_x += 1;
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxY) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][y]+diff < MaxV && gen[x][y]+diff > MinV) {
                        gen[x][y] += diff;
                    }

                    for (time = 0; time < 4; time ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (time == 0 && gen[x-1][y]+diff < MaxV && gen[x-1][y]+diff > MinV) {
                                gen[x-1][y] = Math.round((gen[x][y]+gen[x-1][y])/2);
                                gen[x-1][y] +=diff;
                            }
                            if (time == 1 && gen[x+1][y]+diff < MaxV && gen[x+1][y]+diff > MinV) {
                                gen[x+1][y] = Math.round((gen[x][y]+gen[x+1][y])/2);
                                gen[x+1][y] += diff;
                            }
                        }

                        if (y-1 > 0 && y+1  < MaxY) {
                            if (time == 2 && gen[x][y-1]+diff < MaxV && gen[x][y-1]+diff > MinV) {
                                gen[x][y-1] = Math.round((gen[x][y]+gen[x][y-1])/2);
                                gen[x][y-1] += diff;
                            }
                            if (time == 3 && gen[x][y+1]+diff < MaxV && gen[x][y+1]+diff > MinV) {
                                gen[x][y+1] = Math.round((gen[x][y]+gen[x][y+1])/2);
                                gen[x][y+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;

            if (game_state >= AFTER_TUTORIAL || game_state < START_GAME) {
                if (keyCode == 87 && select > 1) {
                    select -= 1
                } else if (keyCode == 83 && select < OUTPUT_ITEMS[item_select].length) {
                    select += 1
                } else if (keyCode == 13 || keyCode == 32) {
                    user = true;
                }
            }

            if ((keyCode == 8 || keyCode == 27) && (game_state == START_GAME)) {
                game_state = AFTER_TUTORIAL;
            }

            if (response_sequence.length != sequence.length && game_state == SEQUENCE_RESPONSE) {
                if (keyCode == 81) {
                    response_sequence.push("Q");
                }
                if (keyCode == 69) {
                    response_sequence.push("E");
                }
            }
        }

        function keyPress() {
            var keyCode = event.keyCode;

            if (game_state < AFTER_TUTORIAL || game_state == INVENTORY) {
                user = true;
            }

            if (keyCode == 32 && game_state >= START_GAME && game_state <= DURING_GAME) {
                if (scanned == false && active > 0 && cooldown == 0) {
                    cooldown = 50;
                    scanned = true;
                    geode_Render();
                } else {
                    scanned = false;
                }
            }
        }

        function getMousePos(e, canvas) {
            var rect = canvas.getBoundingClientRect();

            scaleX = canvas.width / rect.width;
            scaleY = canvas.height / rect.height;
            zone = [Math.round(rect.width * scaleX), Math.round(rect.height * scaleY)];

            mouse_x = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
            mouse_y = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
        }

        function addItem(item, quantity, quality) {
            if (inventory.includes(item)) {
                for (i = 0; i < inventory.length/2; i++) {
                    if (inventory[i*2] == String(item+" (Q"+quality+")") && quality != 0) {
                        inventory[i*2+1] += 1;
                    } else if (inventory[i*2] == item) {
                        inventory[i*2+1] += 1;
                    }
                }
            } else if (quality > 0){
                inventory.push(item+" (Q"+quality+")");
                inventory.push(quantity);
            } else {
                inventory.push(item);
                inventory.push(quantity);
            }
        }

        function randomItem(itemC, quality) {
            // 0 - Fall catagory, the bad rewards
            if (itemC == 0) {
                r = Math.random();
                if (r > 0.5) {
                    addItem("Dirt", 1, 0);
                } else if (r > 0.4) {
                    addItem("Copper ore", 1, 0);
                } else if (r > 0) {
                    addItem("Stone", 1, 0);
                }
            }
            if (itemC == "Plains") {
                r = Math.random();
                if (r > 0.5) {
                    addItem("Geode", 1, quality);
                } else if (r > 0.4) {
                    addItem("Copper ore", 1, 0);
                } else if (r > 0.3) {
                    addItem("Tin", 1, 0);
                } else if (r > 0.2) {
                    addItem("Fossil", 1, quality);
                } else if (r > 0.19) {
                    addItem("Iron ore", 1, 0);
                } else if (r > 0.18) {
                    addItem("Gold ore", 1, 0);
                } else if (r > 0.16) {
                    addItem("Diamond", 1, quality);
                }  else if (r > 0.15) {
                    addItem("Ruby", 1, quality);
                }  else if (r > 0) {
                    addItem("Geode", 1, quality);
                }
            }
        }

        function displayInv() {
            text = "";
            for (i = 0; i < inventory.length/2; i ++) {
                if (inventory[i*2+1] == 1) {
                    text = String(text+" "+inventory[i*2]+",");
                } else {
                    text = String(text+" "+inventory[i*2+1]+" "+inventory[i*2]+",")
                }
            }
            return text;
        }

        function Click() {

            if (game_state < AFTER_TUTORIAL || game_state == INVENTORY) {
                user = true;
            }

            if (game_state >= DURING_GAME && game_state < SECOND_GAME && dig_attempt.length < attempts*2) {
                if (dig_attempt.length > 2) {
                    diggable = true;
                    for (i = 0; i < dig_attempt.length; i++) {
                        if (mouse_x >= dig_attempt[i*2]-size_X*2 && mouse_x <= dig_attempt[i*2]+size_X*2 && mouse_y >= dig_attempt[i*2+1]-size_Y*2 && mouse_y <= dig_attempt[i*2+1]+size_Y*2) {
                            diggable = false;
                        }
                    }
                } else if (dig_attempt.length == 2) {
                    if (mouse_x >= dig_attempt[0]-size_X*2 && mouse_x <= dig_attempt[0]+size_X*2 && mouse_y >= dig_attempt[1]-size_Y*2 && mouse_y <= dig_attempt[1]+size_Y*2) {
                        diggable = false;
                    } else {
                        diggable = true;
                    }
                } else {
                    diggable = true;
                }

                if (diggable) {
                    dig_attempt.push(mouse_x);
                    dig_attempt.push(mouse_y);
                }
            }
        }
        function draw(type, fill, color, s_color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }

            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke();
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>