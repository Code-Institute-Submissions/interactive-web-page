<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            overflow-y: hidden;
            overflow-x: hidden;
            border: 1px black solid;
        }
        main {
            padding: 20px;
            border: 1px black solid;
        }
        section {
            width: auto;
            height: auto;
            border: 1px black dashed;
            text-indent: 20px;
            padding: 10px;
            margin-bottom: 10px;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <section>
            <b id="name"></b>
            <span id="output"></span>
        </section>
        <canvas onmousemove="getMousePos(event, canvas)" id="Window">This element is unsupported.</canvas>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        let game_state = 0;

        const MapX = 50;
        const MapY = 30;
        const size_X = 6;
        const size_Y = 6;

        let mouse_x = 0;
        let mouse_y = 0;

        let time = 0;
        let night = false;
        let scanned = false;

        let count = 1;
        let active = 0;
        let cooldown = 0;
        let diggable = false;

        let inventory = [];

        let biome_v = "";

        let user = false;
        let bool = false;
        let select = 1;

        let geode = [];
        let entity = []; // 3 Values ID, X, Y
        let dig_attempt = []; // previous dig locations
        let attempts = 3;

        let item_select = 0;

        const AFTER_TUTORIAL = 0.7;
        const START_GAME = 1;
        const DURING_GAME = 1.1;

        const OUTPUT_ITEMS = [["World Map", "Museum", "Inventory"],["Plains", "Desert", "Forest", "Swamp", "Mountain", "Taiga", "Jungle", "Red Desert", "Savannah", "Marsh"]]
        const OUTPUT = ["Welcome to DIG UP! This is a game developed by me just to be presented for my course. The game is only going to have some simple little mini-games and will be just a little bit of fun.", "Hello. I am your assistant, just call me Alph. I will tell you about the game and how to play.", "W and S allow for navigation in menu screens and other text related displays.", "Spacebar and Enter will be the confirm button. But whilst in game will allow the user to visually display the locations of items in the ground.", "Q and E will be part of a digging mini-game, once you have placed down all of your dig locations, I will tell you the way on which you must dig the terrain to prevent items from being damaged.", "A, S and D will also act as a quick time response event within salvaging and recovering geodes and other items.", "Within this part of the screen this will allow for menu select and from here you can chose to see your inventory, also go and find resources and also salvage or obtained items.","What would you like to do?", "", "", "What biome would you like to explore?", "Now you have "+attempts+" attempts to find the items within the terrian, using spacebar you can see the locations of the items."];

        function innit() {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            document.addEventListener("keypress", keyPress);
            document.addEventListener("click", Click);

            document.getElementById("name").innerHTML = "???:"
            document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"<br><br> Press any button to continue.";
            setInterval(alph, 20);
        }

        function OUTPUT_PRINTOUT (items, selected) {
            let temp = "";
            for (x = 0; x < items.length; x++) {
                if (selected-1 == x) {
                    temp = String(temp+"</br><b>"+items[x]+"</b>")
                } else {
                    temp = String(temp+"</br>"+items[x])
                }
            }
            return temp;
        }

        function alph() {
            if (user && game_state < AFTER_TUTORIAL) {
                if (game_state == 0.1) {
                    document.getElementById("name").innerHTML = "Alph:"
                }
                game_state += 0.1;
                user = false;
            }

            if (game_state < AFTER_TUTORIAL) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"<br><br> Press any button to continue.";
            } else if (game_state == AFTER_TUTORIAL) {
                item_select = 0;
                temp = OUTPUT_PRINTOUT(OUTPUT_ITEMS[item_select], select);
                if (user) {
                    user = false;
                    game_state = select;
                    select = 1;
                }
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+temp;
            } else if (game_state == START_GAME) {
                item_select = 1;
                temp = OUTPUT_PRINTOUT(OUTPUT_ITEMS[item_select], select);
                if (user) {
                    user = false;
                    game_state = 1.1;
                    biome_v = OUTPUT_ITEMS[1][select-1];
                    biome(biome_v);
                }
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+temp;
            } else if (game_state == DURING_GAME) {
                document.getElementById("output").innerHTML = OUTPUT[game_state*10]+"</br></br>Attempts: "+dig_attempt;
            }
        }

        function biome(value) {
            if ("Plains") {
                map = new map_Gen(2, 50, 25, MapX, MapY);
            } else if ("Desert") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Forest") {
                map = new map_Gen(5, 50, 25, MapX, MapY);
            } else if ("Swamp") {
                map = new map_Gen(2, 25, 15, MapX, MapY);
            } else if ("Mountain") {
                map = new map_Gen(2, 85, 60, MapX, MapY);
            } else if ("Jungle") {
                map = new map_Gen(2, 30, 20, MapX, MapY);
            } else if ("Taiga") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Red Desert") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Savannah") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            } else if ("Marsh") {
                map = new map_Gen(2, 95, 85, MapX, MapY);
            }
            geode_Gen();
            setInterval(main, 20);
            setInterval(draw, 20);
        }

        function timed_output() {

        }

        function main() {
            if (time % 100 == 0 || time == 10 || scanned == false) {
                map_Render(biome_v, MapX, MapY, 0, 0, size_X, size_Y);
            }

            if (scanned == true) {
                geode_Render();
            }

            if (cooldown > 0) {
                cooldown --;
            }

            if (dig_attempt.length == (attempts+count)*2) {
                setInterval(timed_output, 100);
            }

            if (scanned == true && active > 0) {
                active --;
            } else if (active < 100){
                scanned = false;
                active++;
            }

            if (night == true) {
                time -= 1;
            } else {
                time += 1;
            }

            if (time == 1200) {
                night = true;
            } else if (time == 0) {
                night = false;
            }
        }

        function geode_Render() {
            for (i = 0; i < geode.length/2; i++) {
                draw(1, true, "hsl(0, 0%, 0%)", "", geode[i*2]-size_X, geode[i*2+1]-size_Y, size_X*2, size_Y*2);
            }
        }

        function geode_Gen() {
            if (geode.length < count) {
                for (i = geode.length; i < count; i ++) {
                    temp_pos = [Math.floor(range((Math.random()*zone[0]), size_X*2, zone[0]-size_X*2)), Math.floor(range((Math.random()*zone[1]), size_Y*2, zone[1]-size_Y*2))];
                    geode[geode.length] = parseInt(temp_pos[0]);
                    geode[geode.length] = parseInt(temp_pos[1]);
                }
            }
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        function map_Render(biome, maxX, maxY, cx, cz, size_x, size_z) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (y = cz; y < maxY; y++) {
                    temp_val = map[x][y]-time/100;

                    if (biome == "Plains") {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    } else if (biome == "Desert") {
                        color = "hsl(64, 85%, "+temp_val+"%)";
                    } else if (biome == "Forest") {
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    } else if (biome == "Swamp") {
                        color = "hsl(145, 88%, "+temp_val+"%)";
                    } 

                    draw(1, true, color, "", x*size_x, y*size_z, size_x, size_z);
                    temp_z += 1;
                }
                temp_x += 1;
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxY) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (y = 0; y < MaxY; y++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][y]+diff < MaxV && gen[x][y]+diff > MinV) {
                        gen[x][y] += diff;
                    }

                    for (time = 0; time < 4; time ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (time == 0 && gen[x-1][y]+diff < MaxV && gen[x-1][y]+diff > MinV) {
                                gen[x-1][y] = Math.round((gen[x][y]+gen[x-1][y])/2);
                                gen[x-1][y] +=diff;
                            }
                            if (time == 1 && gen[x+1][y]+diff < MaxV && gen[x+1][y]+diff > MinV) {
                                gen[x+1][y] = Math.round((gen[x][y]+gen[x+1][y])/2);
                                gen[x+1][y] += diff;
                            }
                        }

                        if (y-1 > 0 && y+1  < MaxY) {
                            if (time == 2 && gen[x][y-1]+diff < MaxV && gen[x][y-1]+diff > MinV) {
                                gen[x][y-1] = Math.round((gen[x][y]+gen[x][y-1])/2);
                                gen[x][y-1] += diff;
                            }
                            if (time == 3 && gen[x][y+1]+diff < MaxV && gen[x][y+1]+diff > MinV) {
                                gen[x][y+1] = Math.round((gen[x][y]+gen[x][y+1])/2);
                                gen[x][y+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;
        }

        function keyPress() {
            var keyCode = event.keyCode;

            if (game_state < AFTER_TUTORIAL) {
                user = true;
            }

            if (game_state == AFTER_TUTORIAL || game_state == START_GAME) {
                if (keyCode == 87 && select > 1) {
                    select -= 1
                } else if (keyCode == 83 && select < OUTPUT_ITEMS[item_select].length) {
                    select += 1
                } else if (keyCode == 13 || keyCode == 32) {
                    user = true;
                }
            }

            if (keyCode == 32 && game_state >= 1 && game_state < 2) {
                if (scanned == false && active > 0 && cooldown == 0) {
                    cooldown = 50;
                    scanned = true;
                    geode_Render();
                } else {
                    scanned = false;
                }
            }
        }

        function getMousePos(e, canvas) {
            var rect = canvas.getBoundingClientRect();

            scaleX = canvas.width / rect.width;
            scaleY = canvas.height / rect.height;
            zone = [Math.round(rect.width * scaleX), Math.round(rect.height * scaleY)];

            mouse_x = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
            mouse_y = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
        }

        function addItem(item, quantity) {
            if (inventory.includes(item)) {
                for (i = 0; i < inventory.length/2; i++) {
                    if (inventory[i*2] == item) {
                        inventory[i*2+1] += 1;
                    }
                }
            } else {
                inventory.push(item);
                inventory.push(quantity);
            }
        }

        function randomItem(itemC) {
            if (itemC == 0) {
                addItem("Geode", 1);
            }
            if (itemC == 1) {
                r = Math.random();
                if (r > 0.5) {
                    addItem("Geode", 1);
                } else if (r > 0.4) {
                    addItem("Copper ore", 1);
                } else if (r > 0.3) {
                    addItem("Tin", 1);
                } else if (r > 0.2) {
                    addItem("Fossil", 1);
                } else if (r > 0.19) {
                    addItem("Iron ore", 1);
                } else if (r > 0.18) {
                    addItem("Gold ore", 1);
                } else if (r > 0.16) {
                    addItem("Diamond", 1);
                }  else if (r > 0.15) {
                    addItem("Ruby", 1);
                }  else if (r > 0) {
                    addItem("Geode", 1);
                }
            }
        }

        function displayInv() {
            text = "";
            for (i = 0; i < inventory.length/2; i ++) {
                if (inventory[i*2+1] == 1) {
                    text = String(text+", "+inventory[i*2]);
                }
            }
            return text;
        }

        function Click() {
            if (game_state >= 1 && game_state < 2 && attempts > 0) {
                if (dig_attempt.length > 1) {
                    for (x = 1; x < dig_attempt.length/2; x++) {
                        if (dig_attempt[x*2-1] <= mouse_X-size_X && dig_attempt[x*2-1] >= mouse_X+size_X && dig_attempt[x*2] <= mouse_y-size_Y && dig_attempt[x*2] >= mouse_y+size_Y) {
                            diggable = true;
                        }
                    }
                } else {
                    diggable = true;
                }

                if (diggable == true) {
                    dig_attempt.push(mouse_x);
                    dig_attempt.push(mouse_y);
                    attempts --;
                }
            }
        }

        function draw(type, fill, color, s_color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }

            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke();
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>