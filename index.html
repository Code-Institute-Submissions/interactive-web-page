<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            overflow-y: hidden;
            overflow-x: hidden;
            font-family: "Courier new", "Cambria";
        }
        canvas {
            width: 100%;
            height: auto;
            border: 1px black solid;
            overflow-y: hidden;
            overflow-x: hidden;
        }
        header {
            text-align: center;

        }
        footer {
            text-align: center;
        }
    </style>

    <title>Document</title>
</head>
<body onload="innit()">
    <header>
        <h1>Dig UP!</h1>
        <span>Archeology-base memory game.</span>
    </header>
    <main>
        <span id="output">Output:</span>
        <canvas id="Window">This element is unsupported.</canvas>
    </main>
    <footer>
        <span>Are you having trouble with this game? I have made a quick peice of information to assit you on your digging. <a target="_blank" href="html/help.html">Click here.</a></span>
    </footer>


    <script>
        game_state = 0;
        mx = 0;
        mz = 0;
        vx = 0;
        vz = 0;

        MapX = 100;
        MapZ = 100;

        t = 0;
        night = false;

        geode = []; // 2 values X, Y
        entity = []; // 3 Values ID, X, Y

        function innit() {
            canvas = document.getElementById("Window");
            ctx = canvas.getContext("2d");

            document.addEventListener("keydown", keyDown);
            document.addEventListener("keyup", keyUp);
            document.addEventListener("click", click);

            map = new map_Gen(2, 50, 25, MapX, MapZ);

            setInterval(main, 20);
            setInterval(draw, 20);
        }

        function main() {
            clear();

            document.getElementById("output").innerHTML = String(mx+","+mz);

            if (night == true) {
                t -= 2;
            } else {
                t += 2;
            }

            if (t == 1200) {
                night = true;
            } else if (t == 0) {
                night = false
            }
            
            if (game_state == 0) {
                map_Render(0, (MapX), (MapZ), mx, mz, 3, 3);
            }

            mx = range((mx+vx), 0, MapX);
            mz = range((mz+vz), 0, MapZ);
        }

        function range(c_val, min_val, max_val) {
            if (c_val < min_val) {
                return min_val;
            } else if (c_val > max_val) {
                return max_val;
            } else {
                return c_val;
            }
        }

        // function geode_handler() {
        //     if (geode.length() < 5) {
        //         t_x = Math.random*;
        //         t_z = Math.random*;
        //     }
        // }

        function entity_Gen() {

        }

        function entity_Render() {

        }

        function map_Render(biome, maxX, maxZ, cx, cz, size_x, size_z) {
            temp_x = 0;
            temp_z = 0;
            for (x = cx; x < maxX; x++) {
                for (z = cz; z < maxZ; z++) {
                    // color = "hsl(210, 100%, "+map[x][z]+"%)";
                    if (biome == 0) {
                        temp_val = map[x][z]-t/100;
                        color = "hsl(122, 54%, "+temp_val+"%)";
                    }
                    if (biome == 1) {
                        if (map[x][z] >= 10) {
                            temp_val = range(map[x][z], 10, 20)
                            color = "hsl(100, 93%, "+temp_val+"%)";
                        } else {
                            temp_val = range(map[x][z], 21, 36)
                            color = "hsl(221, 55%, "+temp_val+"%)";
                        }
                    }
                    // if (map[temp_x][temp_z] < 5) {
                        
                    // }
                    draw(1, true, color, x*size_x, z*size_z, size_x, size_z);
                    temp_z += 1
                }
                temp_x += 1
            }
        }

        function map_Gen(gradient, MaxV, MinV, MaxX, MaxZ) {
            var gen = [];
            var temp_gen = [];

            // Initializer
            for (x = 0; x < MaxX; x++) {
                for (z = 0; z < MaxZ; z++) {
                    temp_gen.push(MinV);
                }
                gen.push(temp_gen);
                temp_gen = [];
            }

            for (x = 0; x < MaxX; x++) {
                for (z = 0; z < MaxZ; z++) {
                    r = Math.random()*4;
                    diff = 0;
                    if (Math.round(r) == 0) {
                        diff = gradient * -1;
                    }
                    if (Math.round(r) == 1) {
                        diff = 0;
                    }
                    if (Math.round(r) == 2) {
                        diff = gradient;
                    }
                    
                    if (gen[x][z]+diff < MaxV && gen[x][z]+diff > MinV) {
                        gen[x][z] += diff;
                    }

                    for (t = 0; t < 4; t ++) {
                        if (x-1 > 0 && x+1 < MaxX) {
                            if (t == 0 && gen[x-1][z]+diff < MaxV && gen[x-1][z]+diff > MinV) {
                                gen[x-1][z] = Math.round((gen[x][z]+gen[x-1][z])/2);
                                gen[x-1][z] +=diff;
                            }
                            if (t == 1 && gen[x+1][z]+diff < MaxV && gen[x+1][z]+diff > MinV) {
                                gen[x+1][z] = Math.round((gen[x][z]+gen[x+1][z])/2);
                                gen[x+1][z] += diff;
                            }
                        }

                        if (z-1 > 0 && z+1  < MaxZ) {
                            if (t == 2 && gen[x][z-1]+diff < MaxV && gen[x][z-1]+diff > MinV) {
                                gen[x][z-1] = Math.round((gen[x][z]+gen[x][z-1])/2);
                                gen[x][z-1] += diff;
                            }
                            if (t == 3 && gen[x][z+1]+diff < MaxV && gen[x][z+1]+diff > MinV) {
                                gen[x][z+1] = Math.round((gen[x][z]+gen[x][z+1])/2);
                                gen[x][z+1] += diff;
                            }
                        }
                    }
                }
            }
            return gen;
        }

        function keyDown() {
            var keyCode = event.keyCode;

            if (keyCode == 87) {
                vz = 1;
            }
            if (keyCode == 65) {
                vx = -1;
            }
            if (keyCode == 68) {
                vx = 1;
            }
            if (keyCode == 83) {
                vz = -1;
            }
        }

        function keyUp() {
            var keyCode = event.keyCode;

            if (keyCode == 87) {
                vz = 0;
            }
            if (keyCode == 65) {
                vx = 0;
            }
            if (keyCode == 68) {
                vx = 0;
            }
            if (keyCode == 83) {
                vz = 0;
            }
        }

        function click() {
            document.getElementById("output").innerHTML = "Mouse Click";
        }

        function draw(type, fill, color, x, y, size_x, size_y) {
            ctx.beginPath();

            if (type == 1 && fill == false) {
                ctx.rect(x, y, size_x, size_y);
            }
            if (color != "") {
                if (type == 1 && fill == true) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, size_x, size_y);
                }
            }


            if (fill == true && color == "") {
                ctx.fill();
            }

            ctx.stroke()
        }
        
        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>